module.exports = class BombSweeper {
  static GetAdjacentCellOffsets() {
    return [
      { x: -1, y: -1 },
      { x: 0, y: -1 },
      { x: 1, y: -1 },
      { x: -1, y: 0 },
      { x: 1, y: 0 },
      { x: -1, y: 1 },
      { x: 0, y: 1 },
      { x: 1, y: 1 },
    ];
  }

  static Create2DArray(width, height, defaultCellValue) {
    const result = [];
    while (result.length < height) {
      result.push(new Array(width).fill(defaultCellValue));
    }

    return result;
  }

  static CoordInBounds(x, y, width, height) {
    return x >= 0 && y >= 0 && x < width && y < height;
  }

  constructor(width, height, onWin, onLoss) {
    this.width = width;
    this.height = height;
    this.onWin = onWin;
    this.onLoss = onLoss;

    this.bombCount = 0;
    this.board = BombSweeper.Create2DArray(width, height, 0);
    this.mask = BombSweeper.Create2DArray(width, height, false);
  }

  PlaceBomb(x, y) {
    if (this.board[y][x] === '*') {
      return false;
    }

    // place Bomb
    this.board[y][x] = '*';
    this.bombCount += 1;

    // find all valid adjacent cells on board
    const adjacentCellOffsets = BombSweeper.GetAdjacentCellOffsets()
      .map(offset => ({ x: offset.x + x, y: offset.y + y }))
      .filter(offset => BombSweeper.CoordInBounds(offset.x, offset.y, this.width, this.height));

    // increment all non-star valid adjacent cells
    adjacentCellOffsets.forEach((offset) => {
      if (this.board[offset.y][offset.x] !== '*') {
        this.board[offset.y][offset.x] += 1;
      }
    });

    return true;
  }

  PlaceBombs(count) {
    let currentBombCount = 0;
    do {
      const randX = Math.floor(Math.random() * this.width);
      const randY = Math.floor(Math.random() * this.height);

      if (this.PlaceBomb(randX, randY)) {
        currentBombCount += 1;
      }
    } while (
      currentBombCount < count
      && this.bombCount < this.width * this.height
    );
  }

  CheckCell(x, y) {
    if (this.board[y][x] === '*') {
      if (typeof this.onLoss === 'function') {
        this.mask = BombSweeper.Create2DArray(this.width, this.height, true);
        this.onLoss();
      }
      return;
    }

    // flood fill if cell is a zero
    if (this.board[y][x] === 0) {
      const toCheck = [{ x, y }];
      const checked = [];

      while (toCheck.length > 0) {
        const cellToCheck = toCheck.pop();
        checked.push(cellToCheck);

        this.mask[cellToCheck.y][cellToCheck.x] = true;

        // grab the N, E, S and W offsets
        const adjacentCellsNESW = BombSweeper.GetAdjacentCellOffsets()
          .filter(offset => Math.abs(offset.x) + Math.abs(offset.y) === 1)
          .map(offset => ({ x: offset.x + cellToCheck.x, y: offset.y + cellToCheck.y }))
          .filter(offset => BombSweeper.CoordInBounds(offset.x, offset.y, this.width, this.height));

        adjacentCellsNESW.forEach((adjacentCell) => {
          if (this.board[adjacentCell.y][adjacentCell.x] === 0) {
            const CoordinateMatch = cell => cell.x === adjacentCell.x && cell.y === adjacentCell.y;

            const checkedIndex = checked.findIndex(CoordinateMatch);
            const toCheckIndex = toCheck.findIndex(CoordinateMatch);

            // cell hasn't been checked yet
            if (checkedIndex === -1 && toCheckIndex === -1) {
              toCheck.push(adjacentCell);
            }
          } else {
            this.mask[adjacentCell.y][adjacentCell.x] = true;
          }
        });
      }
    }

    this.mask[y][x] = true;

    let unmaskedCells = 0;
    this.mask.forEach((row) => {
      unmaskedCells += row.reduce((sum, cell) => sum + (cell ? 1 : 0), 0);
    });

    if (unmaskedCells === (this.width * this.height) - this.bombCount) {
      if (typeof this.onWin === 'function') {
        this.mask = BombSweeper.Create2DArray(this.width, this.height, true);
        this.onWin();
      }
    }
  }
};
