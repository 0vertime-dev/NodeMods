'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  _createClass(BombSweeper, null, [{
    key: 'GetAdjacentCellOffsets',
    value: function GetAdjacentCellOffsets() {
      return [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }];
    }
  }, {
    key: 'Create2DArray',
    value: function Create2DArray(width, height, defaultCellValue) {
      var result = [];
      while (result.length < height) {
        result.push(new Array(width).fill(defaultCellValue));
      }

      return result;
    }
  }, {
    key: 'CoordInBounds',
    value: function CoordInBounds(x, y, width, height) {
      return x >= 0 && y >= 0 && x < width && y < height;
    }
  }]);

  function BombSweeper(width, height, onWin, onLoss) {
    _classCallCheck(this, BombSweeper);

    this.width = width;
    this.height = height;
    this.onWin = onWin;
    this.onLoss = onLoss;

    this.bombCount = 0;
    this.board = BombSweeper.Create2DArray(width, height, 0);
    this.mask = BombSweeper.Create2DArray(width, height, false);
  }

  _createClass(BombSweeper, [{
    key: 'PlaceBomb',
    value: function PlaceBomb(x, y) {
      var _this = this;

      if (this.board[y][x] === '*') {
        return false;
      }

      // place Bomb
      this.board[y][x] = '*';
      this.bombCount += 1;

      // find all valid adjacent cells on board
      var adjacentCellOffsets = BombSweeper.GetAdjacentCellOffsets().map(function (offset) {
        return { x: offset.x + x, y: offset.y + y };
      }).filter(function (offset) {
        return BombSweeper.CoordInBounds(offset.x, offset.y, _this.width, _this.height);
      });

      // increment all non-star valid adjacent cells
      adjacentCellOffsets.forEach(function (offset) {
        if (_this.board[offset.y][offset.x] !== '*') {
          _this.board[offset.y][offset.x] += 1;
        }
      });

      return true;
    }
  }, {
    key: 'PlaceBombs',
    value: function PlaceBombs(count) {
      var currentBombCount = 0;
      do {
        var randX = Math.floor(Math.random() * this.width);
        var randY = Math.floor(Math.random() * this.height);

        if (this.PlaceBomb(randX, randY)) {
          currentBombCount += 1;
        }
      } while (currentBombCount < count && this.bombCount < this.width * this.height);
    }
  }, {
    key: 'CheckCell',
    value: function CheckCell(x, y) {
      var _this2 = this;

      if (this.board[y][x] === '*') {
        if (typeof this.onLoss === 'function') {
          this.mask = BombSweeper.Create2DArray(this.width, this.height, true);
          this.onLoss();
        }
        return;
      }

      // flood fill if cell is a zero
      if (this.board[y][x] === 0) {
        (function () {
          var toCheck = [{ x: x, y: y }];
          var checked = [];

          var _loop = function _loop() {
            var cellToCheck = toCheck.pop();
            checked.push(cellToCheck);

            _this2.mask[cellToCheck.y][cellToCheck.x] = true;

            // grab the N, E, S and W offsets
            var adjacentCellsNESW = BombSweeper.GetAdjacentCellOffsets().filter(function (offset) {
              return Math.abs(offset.x) + Math.abs(offset.y) === 1;
            }).map(function (offset) {
              return { x: offset.x + cellToCheck.x, y: offset.y + cellToCheck.y };
            }).filter(function (offset) {
              return BombSweeper.CoordInBounds(offset.x, offset.y, _this2.width, _this2.height);
            });

            adjacentCellsNESW.forEach(function (adjacentCell) {
              if (_this2.board[adjacentCell.y][adjacentCell.x] === 0) {
                var CoordinateMatch = function CoordinateMatch(cell) {
                  return cell.x === adjacentCell.x && cell.y === adjacentCell.y;
                };

                var checkedIndex = checked.findIndex(CoordinateMatch);
                var toCheckIndex = toCheck.findIndex(CoordinateMatch);

                // cell hasn't been checked yet
                if (checkedIndex === -1 && toCheckIndex === -1) {
                  toCheck.push(adjacentCell);
                }
              } else {
                _this2.mask[adjacentCell.y][adjacentCell.x] = true;
              }
            });
          };

          while (toCheck.length > 0) {
            _loop();
          }
        })();
      }

      this.mask[y][x] = true;

      var unmaskedCells = 0;
      this.mask.forEach(function (row) {
        unmaskedCells += row.reduce(function (sum, cell) {
          return sum + (cell ? 1 : 0);
        }, 0);
      });

      if (unmaskedCells === this.width * this.height - this.bombCount) {
        if (typeof this.onWin === 'function') {
          this.mask = BombSweeper.Create2DArray(this.width, this.height, true);
          this.onWin();
        }
      }
    }
  }]);

  return BombSweeper;
}();